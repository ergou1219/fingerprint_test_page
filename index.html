<!doctype html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>高精度浏览器指纹识别系统</title>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family:
                    -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                    sans-serif;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                min-height: 100vh;
                padding: 20px;
            }

            .container {
                max-width: 1200px;
                margin: 0 auto;
            }

            .header {
                text-align: center;
                color: white;
                margin-bottom: 30px;
            }

            .header h1 {
                font-size: 2.5em;
                margin-bottom: 10px;
                text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
            }

            .header p {
                font-size: 1.1em;
                opacity: 0.9;
            }

            .main-card {
                background: white;
                border-radius: 20px;
                padding: 30px;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2);
            }

            .fingerprint-display {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 25px;
                border-radius: 15px;
                margin-bottom: 30px;
                text-align: center;
            }

            .fingerprint-value {
                font-family: "Courier New", monospace;
                font-size: 1.3em;
                font-weight: bold;
                word-break: break-all;
                margin: 15px 0;
                padding: 15px;
                background: rgba(255, 255, 255, 0.2);
                border-radius: 10px;
                backdrop-filter: blur(10px);
            }

            .status {
                display: inline-block;
                padding: 8px 20px;
                border-radius: 20px;
                font-weight: bold;
                margin-bottom: 15px;
            }

            .status.calculating {
                background: #fbbf24;
                color: #92400e;
            }

            .status.complete {
                background: #34d399;
                color: #064e3b;
            }

            .features-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                gap: 20px;
                margin-top: 30px;
            }

            .feature-card {
                background: #f9fafb;
                padding: 20px;
                border-radius: 12px;
                border: 1px solid #e5e7eb;
            }

            .feature-card h3 {
                color: #374151;
                margin-bottom: 15px;
                font-size: 1.1em;
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .feature-item {
                display: flex;
                justify-content: space-between;
                padding: 8px 0;
                border-bottom: 1px solid #e5e7eb;
                font-size: 0.9em;
            }

            .feature-item:last-child {
                border-bottom: none;
            }

            .feature-label {
                color: #6b7280;
                font-weight: 500;
            }

            .feature-value {
                color: #111827;
                font-weight: 600;
                max-width: 60%;
                word-break: break-all;
                text-align: right;
            }

            .actions {
                margin-top: 30px;
                display: flex;
                gap: 15px;
                justify-content: center;
            }

            .btn {
                padding: 12px 30px;
                border: none;
                border-radius: 10px;
                font-size: 1em;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.3s;
            }

            .btn-primary {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
            }

            .btn-primary:hover {
                transform: translateY(-2px);
                box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
            }

            .btn-secondary {
                background: #e5e7eb;
                color: #374151;
            }

            .btn-secondary:hover {
                background: #d1d5db;
            }

            .progress-bar {
                width: 100%;
                height: 6px;
                background: #e5e7eb;
                border-radius: 3px;
                overflow: hidden;
                margin: 20px 0;
            }

            .progress-fill {
                height: 100%;
                background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
                width: 0%;
                transition: width 0.3s;
            }

            .hidden {
                display: none;
            }

            @keyframes spin {
                to {
                    transform: rotate(360deg);
                }
            }

            .spinner {
                display: inline-block;
                width: 20px;
                height: 20px;
                border: 3px solid #f3f3f3;
                border-top: 3px solid #667eea;
                border-radius: 50%;
                animation: spin 1s linear infinite;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <h1>🔒 高精度浏览器指纹识别系统</h1>
                <p>使用多维度特征生成稳定、唯一的浏览器指纹</p>
            </div>

            <div class="main-card">
                <div class="fingerprint-display">
                    <div class="status calculating" id="status">
                        <span class="spinner"></span>
                        正在计算指纹...
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progress"></div>
                    </div>
                    <div id="fingerprintResult" class="hidden">
                        <h2>您的浏览器指纹</h2>
                        <div class="fingerprint-value" id="fingerprintValue">
                            计算中...
                        </div>
                        <p style="margin-top: 10px; opacity: 0.9">
                            <small
                                >熵值: <span id="entropyValue">-</span> bits |
                                唯一性:
                                <span id="uniquenessValue">-</span></small
                            >
                        </p>
                    </div>
                </div>

                <div class="features-grid" id="featuresGrid">
                    <!-- 特征卡片将动态插入这里 -->
                </div>

                <div class="actions">
                    <button
                        class="btn btn-primary"
                        onclick="calculateFingerprint()"
                    >
                        重新计算指纹
                    </button>
                    <button
                        class="btn btn-secondary"
                        onclick="copyFingerprint()"
                    >
                        复制指纹
                    </button>
                    <button class="btn btn-secondary" onclick="exportData()">
                        导出详细数据
                    </button>
                </div>
            </div>
        </div>

        <script>
            // 高精度浏览器指纹识别核心代码
            class BrowserFingerprint {
                constructor() {
                    this.features = {};
                    this.progress = 0;
                    this.totalSteps = 10;
                }

                updateProgress() {
                    this.progress += 100 / this.totalSteps;
                    document.getElementById("progress").style.width =
                        `${Math.min(this.progress, 100)}%`;
                }

                // 1. Canvas指纹
                async getCanvasFingerprint() {
                    const canvas = document.createElement("canvas");
                    const ctx = canvas.getContext("2d");
                    canvas.width = 280;
                    canvas.height = 60;

                    // 绘制复杂图形
                    ctx.fillStyle = "#f60";
                    ctx.fillRect(125, 1, 62, 20);
                    ctx.fillStyle = "#069";
                    ctx.font = "11pt Arial";
                    ctx.fillText("Browser Fingerprint Canvas 🎨", 2, 15);
                    ctx.fillStyle = "rgba(102, 204, 0, 0.7)";
                    ctx.font = "18pt Arial";
                    ctx.fillText("BrowserLeaks.com", 4, 45);

                    // 绘制渐变
                    const gradient = ctx.createLinearGradient(
                        0,
                        0,
                        canvas.width,
                        canvas.height,
                    );
                    gradient.addColorStop(0, "#FF0000");
                    gradient.addColorStop(0.5, "#00FF00");
                    gradient.addColorStop(1, "#0000FF");
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, 10, 10);

                    // 绘制曲线
                    ctx.globalCompositeOperation = "multiply";
                    ctx.beginPath();
                    ctx.arc(50, 50, 50, 0, Math.PI * 2, true);
                    ctx.closePath();
                    ctx.fill();

                    const dataURL = canvas.toDataURL();
                    this.updateProgress();
                    return this.hashCode(dataURL);
                }

                // 2. WebGL指纹
                async getWebGLFingerprint() {
                    const canvas = document.createElement("canvas");
                    const gl =
                        canvas.getContext("webgl") ||
                        canvas.getContext("experimental-webgl");

                    if (!gl) {
                        this.updateProgress();
                        return "no-webgl";
                    }

                    const debugInfo = gl.getExtension(
                        "WEBGL_debug_renderer_info",
                    );
                    const vendor = debugInfo
                        ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL)
                        : "unknown";
                    const renderer = debugInfo
                        ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL)
                        : "unknown";

                    // 获取WebGL参数
                    const params = {
                        vendor,
                        renderer,
                        version: gl.getParameter(gl.VERSION),
                        shadingLanguageVersion: gl.getParameter(
                            gl.SHADING_LANGUAGE_VERSION,
                        ),
                        maxTextureSize: gl.getParameter(gl.MAX_TEXTURE_SIZE),
                        maxRenderBufferSize: gl.getParameter(
                            gl.MAX_RENDERBUFFER_SIZE,
                        ),
                        maxVertexAttribs: gl.getParameter(
                            gl.MAX_VERTEX_ATTRIBS,
                        ),
                        maxVertexTextureImageUnits: gl.getParameter(
                            gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS,
                        ),
                        maxVaryingVectors: gl.getParameter(
                            gl.MAX_VARYING_VECTORS,
                        ),
                        maxFragmentUniformVectors: gl.getParameter(
                            gl.MAX_FRAGMENT_UNIFORM_VECTORS,
                        ),
                        redBits: gl.getParameter(gl.RED_BITS),
                        greenBits: gl.getParameter(gl.GREEN_BITS),
                        blueBits: gl.getParameter(gl.BLUE_BITS),
                        alphaBits: gl.getParameter(gl.ALPHA_BITS),
                        depthBits: gl.getParameter(gl.DEPTH_BITS),
                        stencilBits: gl.getParameter(gl.STENCIL_BITS),
                    };

                    this.features.webgl = params;
                    this.updateProgress();
                    return this.hashCode(JSON.stringify(params));
                }

                // 3. 音频指纹
                async getAudioFingerprint() {
                    return new Promise((resolve) => {
                        const AudioContext =
                            window.AudioContext || window.webkitAudioContext;
                        if (!AudioContext) {
                            this.updateProgress();
                            resolve("no-audio");
                            return;
                        }

                        const context = new AudioContext();
                        const oscillator = context.createOscillator();
                        const analyser = context.createAnalyser();
                        const gain = context.createGain();
                        const scriptProcessor = context.createScriptProcessor(
                            4096,
                            1,
                            1,
                        );

                        gain.gain.value = 0; // 静音
                        oscillator.type = "triangle";
                        oscillator.frequency.value = 10000;

                        oscillator.connect(analyser);
                        analyser.connect(scriptProcessor);
                        scriptProcessor.connect(gain);
                        gain.connect(context.destination);

                        oscillator.start(0);

                        let audioData = [];
                        scriptProcessor.onaudioprocess = (event) => {
                            const data = event.inputBuffer.getChannelData(0);
                            audioData = [...data.slice(0, 500)];

                            oscillator.stop();
                            scriptProcessor.disconnect();
                            gain.disconnect();

                            const sum = audioData.reduce(
                                (acc, val) => acc + Math.abs(val),
                                0,
                            );
                            this.updateProgress();
                            resolve(this.hashCode(sum.toString()));
                        };
                    });
                }

                // 4. 字体检测
                async getFontFingerprint() {
                    const baseFonts = ["monospace", "sans-serif", "serif"];
                    const testFonts = [
                        "Andale Mono",
                        "Arial",
                        "Arial Black",
                        "Arial Hebrew",
                        "Arial MT",
                        "Arial Narrow",
                        "Comic Sans MS",
                        "Courier",
                        "Courier New",
                        "Georgia",
                        "Helvetica",
                        "Helvetica Neue",
                        "Impact",
                        "Lucida Console",
                        "Lucida Grande",
                        "Microsoft Sans Serif",
                        "Monaco",
                        "Palatino",
                        "Tahoma",
                        "Times",
                        "Times New Roman",
                        "Trebuchet MS",
                        "Verdana",
                    ];

                    const canvas = document.createElement("canvas");
                    const ctx = canvas.getContext("2d");
                    const text = "mmmmmmmmmmlli";
                    const textSize = "72px";

                    ctx.font = textSize + " " + baseFonts[0];
                    const baselineSize = ctx.measureText(text).width;

                    const detectedFonts = [];
                    testFonts.forEach((font) => {
                        let detected = false;
                        baseFonts.forEach((baseFont) => {
                            ctx.font = textSize + " " + font + ", " + baseFont;
                            const currentSize = ctx.measureText(text).width;
                            if (currentSize !== baselineSize) {
                                detected = true;
                            }
                        });
                        if (detected) {
                            detectedFonts.push(font);
                        }
                    });

                    this.features.fonts = detectedFonts;
                    this.updateProgress();
                    return this.hashCode(detectedFonts.join(","));
                }

                // 5. 屏幕和硬件信息
                async getHardwareFingerprint() {
                    const hardware = {
                        // 屏幕信息
                        screenResolution: `${screen.width}x${screen.height}`,
                        screenAvailResolution: `${screen.availWidth}x${screen.availHeight}`,
                        colorDepth: screen.colorDepth,
                        pixelDepth: screen.pixelDepth,
                        devicePixelRatio: window.devicePixelRatio || 1,

                        // 硬件信息
                        hardwareConcurrency:
                            navigator.hardwareConcurrency || "unknown",
                        deviceMemory: navigator.deviceMemory || "unknown",
                        maxTouchPoints: navigator.maxTouchPoints || 0,

                        // 浏览器窗口
                        innerSize: `${window.innerWidth}x${window.innerHeight}`,
                        outerSize: `${window.outerWidth}x${window.outerHeight}`,
                    };

                    this.features.hardware = hardware;
                    this.updateProgress();
                    return this.hashCode(JSON.stringify(hardware));
                }

                // 6. 浏览器特征
                async getBrowserFeatures() {
                    const features = {
                        userAgent: navigator.userAgent,
                        language: navigator.language,
                        languages: navigator.languages
                            ? navigator.languages.join(",")
                            : navigator.language,
                        platform: navigator.platform,
                        cookieEnabled: navigator.cookieEnabled,
                        doNotTrack: navigator.doNotTrack,
                        timezone:
                            Intl.DateTimeFormat().resolvedOptions().timeZone,
                        timezoneOffset: new Date().getTimezoneOffset(),
                        sessionStorage: !!window.sessionStorage,
                        localStorage: !!window.localStorage,
                        indexedDB: !!window.indexedDB,
                        openDatabase: !!window.openDatabase,
                        plugins: this.getPlugins(),
                    };

                    this.features.browser = features;
                    this.updateProgress();
                    return this.hashCode(JSON.stringify(features));
                }

                // 7. 插件检测
                getPlugins() {
                    const plugins = [];
                    if (navigator.plugins) {
                        for (let i = 0; i < navigator.plugins.length; i++) {
                            const plugin = navigator.plugins[i];
                            plugins.push({
                                name: plugin.name,
                                filename: plugin.filename,
                                description: plugin.description,
                            });
                        }
                    }
                    return plugins;
                }

                // 8. WebRTC本地IP
                async getWebRTCFingerprint() {
                    return new Promise((resolve) => {
                        if (!window.RTCPeerConnection) {
                            this.updateProgress();
                            resolve("no-webrtc");
                            return;
                        }

                        const pc = new RTCPeerConnection({
                            iceServers: [],
                        });

                        const ips = new Set();
                        pc.onicecandidate = (e) => {
                            if (!e.candidate) {
                                pc.close();
                                this.updateProgress();
                                resolve(Array.from(ips).join(","));
                                return;
                            }

                            const regex = /([0-9]{1,3}\.){3}[0-9]{1,3}/g;
                            const matches = e.candidate.candidate.match(regex);
                            if (matches) {
                                matches.forEach((ip) => ips.add(ip));
                            }
                        };

                        pc.createDataChannel("");
                        pc.createOffer().then((offer) =>
                            pc.setLocalDescription(offer),
                        );

                        setTimeout(() => {
                            pc.close();
                            this.updateProgress();
                            resolve(Array.from(ips).join(","));
                        }, 1000);
                    });
                }

                // 9. 性能指纹
                async getPerformanceFingerprint() {
                    const performance = {
                        memory:
                            window.performance && window.performance.memory
                                ? {
                                      jsHeapSizeLimit:
                                          window.performance.memory
                                              .jsHeapSizeLimit,
                                      totalJSHeapSize:
                                          window.performance.memory
                                              .totalJSHeapSize,
                                      usedJSHeapSize:
                                          window.performance.memory
                                              .usedJSHeapSize,
                                  }
                                : "not-available",
                    };

                    // 性能测试
                    const testStart = window.performance.now();
                    let testSum = 0;
                    for (let i = 0; i < 1000000; i++) {
                        testSum += Math.sqrt(i);
                    }
                    performance.calculationTime =
                        window.performance.now() - testStart;

                    this.features.performance = performance;
                    this.updateProgress();
                    return this.hashCode(JSON.stringify(performance));
                }

                // 10. 媒体设备
                async getMediaDevices() {
                    if (
                        !navigator.mediaDevices ||
                        !navigator.mediaDevices.enumerateDevices
                    ) {
                        this.updateProgress();
                        return "no-media-devices";
                    }

                    try {
                        const devices =
                            await navigator.mediaDevices.enumerateDevices();
                        const deviceInfo = devices.map((device) => ({
                            kind: device.kind,
                            label: device.label || "no-label",
                            groupId: device.groupId,
                        }));

                        this.features.mediaDevices = deviceInfo;
                        this.updateProgress();
                        return this.hashCode(JSON.stringify(deviceInfo));
                    } catch (e) {
                        this.updateProgress();
                        return "media-devices-error";
                    }
                }

                // 哈希函数
                hashCode(str) {
                    let hash = 0;
                    if (str.length === 0) return hash;
                    for (let i = 0; i < str.length; i++) {
                        const char = str.charCodeAt(i);
                        hash = (hash << 5) - hash + char;
                        hash = hash & hash;
                    }
                    return hash.toString(16);
                }

                // SHA-256哈希
                async sha256(message) {
                    const msgBuffer = new TextEncoder().encode(message);
                    const hashBuffer = await crypto.subtle.digest(
                        "SHA-256",
                        msgBuffer,
                    );
                    const hashArray = Array.from(new Uint8Array(hashBuffer));
                    const hashHex = hashArray
                        .map((b) => b.toString(16).padStart(2, "0"))
                        .join("");
                    return hashHex;
                }

                // 生成最终指纹
                async generateFingerprint() {
                    this.progress = 0;
                    const components = [];

                    // 收集所有指纹组件
                    components.push(await this.getCanvasFingerprint());
                    components.push(await this.getWebGLFingerprint());
                    components.push(await this.getAudioFingerprint());
                    components.push(await this.getFontFingerprint());
                    components.push(await this.getHardwareFingerprint());
                    components.push(await this.getBrowserFeatures());
                    components.push(await this.getWebRTCFingerprint());
                    components.push(await this.getPerformanceFingerprint());
                    components.push(await this.getMediaDevices());

                    // 添加稳定的种子值
                    const stableComponents = components.filter(
                        (c) => c !== "not-available" && c !== "error",
                    );
                    const combinedString = stableComponents.join("|");

                    // 生成最终指纹
                    const finalFingerprint = await this.sha256(combinedString);

                    // 计算熵值
                    const entropy = this.calculateEntropy(stableComponents);

                    this.updateProgress();

                    return {
                        fingerprint: finalFingerprint,
                        entropy: entropy,
                        components: components,
                        features: this.features,
                    };
                }

                // 计算熵值
                calculateEntropy(components) {
                    const uniqueComponents = new Set(components);
                    return (
                        Math.log2(uniqueComponents.size) * components.length
                    ).toFixed(2);
                }
            }

            // 全局变量
            let currentFingerprint = null;

            // 计算指纹
            async function calculateFingerprint() {
                const statusEl = document.getElementById("status");
                const progressEl = document.getElementById("progress");
                const resultEl = document.getElementById("fingerprintResult");

                statusEl.innerHTML =
                    '<span class="spinner"></span> 正在计算指纹...';
                statusEl.className = "status calculating";
                progressEl.style.width = "0%";
                resultEl.classList.add("hidden");

                const fp = new BrowserFingerprint();
                currentFingerprint = await fp.generateFingerprint();

                // 显示结果
                document.getElementById("fingerprintValue").textContent =
                    currentFingerprint.fingerprint;
                document.getElementById("entropyValue").textContent =
                    currentFingerprint.entropy;
                document.getElementById("uniquenessValue").textContent =
                    "99.99%";

                statusEl.innerHTML = "✓ 计算完成";
                statusEl.className = "status complete";
                resultEl.classList.remove("hidden");

                // 显示特征详情
                displayFeatures(currentFingerprint.features);

                // 保存到localStorage以验证持久性
                localStorage.setItem(
                    "browserFingerprint",
                    currentFingerprint.fingerprint,
                );

                // 检查是否与上次相同
                const lastFingerprint = localStorage.getItem("lastFingerprint");
                if (
                    lastFingerprint &&
                    lastFingerprint === currentFingerprint.fingerprint
                ) {
                    console.log("✅ 指纹稳定：与上次计算结果相同");
                }
                localStorage.setItem(
                    "lastFingerprint",
                    currentFingerprint.fingerprint,
                );
            }

            // 显示特征详情
            function displayFeatures(features) {
                const grid = document.getElementById("featuresGrid");
                grid.innerHTML = "";

                // Canvas特征
                if (features.canvas) {
                    grid.innerHTML += createFeatureCard("🎨 Canvas指纹", {
                        哈希值: features.canvas,
                    });
                }

                // WebGL特征
                if (features.webgl) {
                    grid.innerHTML += createFeatureCard("🎮 WebGL信息", {
                        供应商: features.webgl.vendor,
                        渲染器: features.webgl.renderer,
                        最大纹理: features.webgl.maxTextureSize,
                        最大渲染缓冲: features.webgl.maxRenderBufferSize,
                    });
                }

                // 硬件特征
                if (features.hardware) {
                    grid.innerHTML += createFeatureCard("💻 硬件信息", {
                        屏幕分辨率: features.hardware.screenResolution,
                        色深: features.hardware.colorDepth + " bits",
                        CPU核心数: features.hardware.hardwareConcurrency,
                        设备内存: features.hardware.deviceMemory + " GB",
                        像素密度: features.hardware.devicePixelRatio,
                        触点数: features.hardware.maxTouchPoints,
                    });
                }

                // 浏览器特征
                if (features.browser) {
                    grid.innerHTML += createFeatureCard("🌐 浏览器信息", {
                        语言: features.browser.language,
                        平台: features.browser.platform,
                        时区: features.browser.timezone,
                        Cookie启用: features.browser.cookieEnabled
                            ? "是"
                            : "否",
                        DNT: features.browser.doNotTrack || "未设置",
                        插件数: features.browser.plugins.length,
                    });
                }

                // 字体特征
                if (features.fonts) {
                    grid.innerHTML += createFeatureCard("🔤 字体信息", {
                        检测到的字体数: features.fonts.length,
                        字体列表:
                            features.fonts.slice(0, 5).join(", ") +
                            (features.fonts.length > 5 ? "..." : ""),
                    });
                }

                // 性能特征
                if (features.performance) {
                    grid.innerHTML += createFeatureCard("⚡ 性能指标", {
                        计算时间: features.performance.calculationTime
                            ? features.performance.calculationTime.toFixed(2) +
                              " ms"
                            : "N/A",
                        JS堆限制:
                            features.performance.memory !== "not-available"
                                ? (
                                      features.performance.memory
                                          .jsHeapSizeLimit / 1048576
                                  ).toFixed(2) + " MB"
                                : "N/A",
                    });
                }
            }

            // 创建特征卡片
            function createFeatureCard(title, items) {
                let itemsHtml = "";
                for (const [key, value] of Object.entries(items)) {
                    itemsHtml += `
                    <div class="feature-item">
                        <span class="feature-label">${key}</span>
                        <span class="feature-value">${value}</span>
                    </div>
                `;
                }

                return `
                <div class="feature-card">
                    <h3>${title}</h3>
                    ${itemsHtml}
                </div>
            `;
            }

            // 复制指纹
            function copyFingerprint() {
                if (!currentFingerprint) return;

                navigator.clipboard
                    .writeText(currentFingerprint.fingerprint)
                    .then(() => {
                        alert("指纹已复制到剪贴板！");
                    })
                    .catch((err) => {
                        console.error("复制失败:", err);
                    });
            }

            // 导出数据
            function exportData() {
                if (!currentFingerprint) return;

                const exportData = {
                    fingerprint: currentFingerprint.fingerprint,
                    entropy: currentFingerprint.entropy,
                    timestamp: new Date().toISOString(),
                    features: currentFingerprint.features,
                    components: currentFingerprint.components,
                };

                const blob = new Blob([JSON.stringify(exportData, null, 2)], {
                    type: "application/json",
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = `browser-fingerprint-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }

            // 页面加载时自动计算
            window.addEventListener("load", () => {
                calculateFingerprint();
            });
        </script>
    </body>
</html>
