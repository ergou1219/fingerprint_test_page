<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>浏览器指纹测试（稳定/严格双哈希）</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 20px; color: #222; }
    h1 { font-size: 20px; margin-bottom: 8px; }
    .row { margin: 8px 0; }
    code { background: #f4f4f4; padding: 2px 4px; border-radius: 3px; }
    button { padding: 6px 10px; margin-left: 8px; }
    pre { background: #f9fafb; padding: 12px; border-radius: 6px; overflow: auto; }
    small { color: #666; }
    details { margin-top: 10px; }
  </style>
</head>
<body>
  <h1>浏览器指纹测试（稳定/严格双哈希）</h1>
  <div class="row"><small id="note">建议在 https 或 http://localhost 下测试；file:// 下部分能力不可用。</small></div>

  <div class="row">
    <div>稳定指纹 stableHash（尽量刷新不变）：
      <code id="stableHash">计算中…</code>
      <button id="copyStable">复制</button>
    </div>
  </div>

  <div class="row">
    <div>严格指纹 strictHash（包含高区分度信号，可能在隐私模式下变化）：
      <code id="strictHash">计算中…</code>
      <button id="copyStrict">复制</button>
    </div>
  </div>

  <div class="row">
    <button id="recalc">重新计算</button>
  </div>

  <details open>
    <summary>查看原始指纹数据（稳定/严格组成）</summary>
    <pre id="details">收集中…</pre>
  </details>

<script>
(function() {
  const enc = new TextEncoder();

  // 简洁稳定的 64-bit FNV-1a 哈希（十六进制），离线可用
  function hash64(str) {
    try {
      const FNV_PRIME = 1099511628211n;
      const OFFSET = 14695981039346656037n;
      let h = OFFSET;
      const bytes = enc.encode(str);
      for (let i = 0; i < bytes.length; i++) {
        h ^= BigInt(bytes[i]);
        h = (h * FNV_PRIME) & 0xFFFFFFFFFFFFFFFFn;
      }
      return h.toString(16).padStart(16, '0');
    } catch (e) {
      // 极老环境退化到 32-bit（现代 Chrome 不会走到这里）
      let h = 0x811c9dc5 >>> 0;
      for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h = (h * 0x01000193) >>> 0;
      }
      return ('00000000' + h.toString(16)).slice(-8);
    }
  }

  // 稳定的 JSON 序列化（递归排序键）
  function stableStringify(obj) {
    const seen = new WeakSet();
    function inner(o) {
      if (o === null || typeof o !== 'object') return o;
      if (seen.has(o)) return null;
      seen.add(o);
      if (Array.isArray(o)) return o.map(inner);
      const out = {};
      Object.keys(o).sort().forEach(k => { out[k] = inner(o[k]); });
      return out;
    }
    return JSON.stringify(inner(obj));
  }

  function normalizeBrandList(list) {
    try {
      const known = ['Chromium','Google Chrome','Microsoft Edge','Opera','OPR','Brave','Vivaldi','Samsung Internet','YaBrowser','Yandex','Chrome','Edge','UC Browser','QQBrowser'];
      const cleaned = (list || [])
        .map(x => ({ brand: x.brand || x.brandName || '', version: x.version || x.versionNumber || '' }))
        .filter(x => x.brand && known.some(k => x.brand.includes(k)));
      cleaned.sort((a, b) => (a.brand + a.version).localeCompare(b.brand + b.version));
      return cleaned;
    } catch (e) { return []; }
  }

  async function getUAData() {
    const result = {
      userAgent: navigator.userAgent || '',
      platform: navigator.platform || '',
      languages: (navigator.languages || [navigator.language || '']).slice().filter(Boolean)
    };
    result.languages.sort();
    const uaData = navigator.userAgentData;
    if (uaData && uaData.getHighEntropyValues) {
      try {
        const high = await uaData.getHighEntropyValues([
          'architecture','bitness','model','platform','platformVersion','uaFullVersion','fullVersionList','wow64'
        ]);
        result.uaData = {
          mobile: !!uaData.mobile,
          architecture: high.architecture || '',
          bitness: high.bitness || '',
          model: high.model || '',
          platform: high.platform || '',
          platformVersion: high.platformVersion || '',
          uaFullVersion: high.uaFullVersion || '',
          wow64: !!high.wow64,
          brands: normalizeBrandList(high.fullVersionList || uaData.brands || [])
        };
      } catch (e) {
        result.uaDataError = String(e);
      }
    }
    return result;
  }

  function getNavigatorProps() {
    return {
      hardwareConcurrency: navigator.hardwareConcurrency ?? null,
      deviceMemory: navigator.deviceMemory ?? null,
      maxTouchPoints: navigator.maxTouchPoints ?? 0,
      vendor: navigator.vendor || '',
      product: navigator.product || '',
      productSub: navigator.productSub || '',
      doNotTrack: navigator.doNotTrack ?? null,
      webdriver: !!navigator.webdriver,
      cookieEnabled: !!navigator.cookieEnabled,
      onLine: !!navigator.onLine
    };
  }

  function getScreenProps() {
    const s = window.screen || {};
    const o = s.orientation || {};
    return {
      width: s.width ?? null,
      height: s.height ?? null,
      availWidth: s.availWidth ?? null,
      availHeight: s.availHeight ?? null,
      colorDepth: s.colorDepth ?? null,
      pixelDepth: s.pixelDepth ?? null,
      devicePixelRatio: window.devicePixelRatio || 1,
      orientationType: o.type || '',
      orientationAngle: o.angle || 0
    };
  }

  function getTZProps() {
    const tz = (Intl && Intl.DateTimeFormat) ? Intl.DateTimeFormat().resolvedOptions().timeZone : '';
    const offset = new Date().getTimezoneOffset();
    const locale = (navigator.languages && navigator.languages[0]) || navigator.language || '';
    return { timeZone: tz || '', timeOffsetMinutes: offset, locale };
  }

  function getWebGLInfo() {
    const out = {};
    try {
      const canvas = document.createElement('canvas');
      const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
      if (gl) {
        const dbg = gl.getExtension('WEBGL_debug_renderer_info');
        out.vendor = gl.getParameter(dbg ? dbg.UNMASKED_VENDOR_WEBGL : gl.VENDOR);
        out.renderer = gl.getParameter(dbg ? dbg.UNMASKED_RENDERER_WEBGL : gl.RENDERER);
        out.version = gl.getParameter(gl.VERSION);
        out.shadingLanguage = gl.getParameter(gl.SHADING_LANGUAGE_VERSION);
        const aniso = gl.getExtension('EXT_texture_filter_anisotropic') ||
                      gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic') ||
                      gl.getExtension('MOZ_EXT_texture_filter_anisotropic');
        out.maxAnisotropy = aniso ? gl.getParameter(aniso.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : null;
      } else {
        out.error = 'no-webgl';
      }
    } catch (e) { out.error = String(e); }
    return out;
  }

  function getCanvasFingerprint() {
    try {
      const canvas = document.createElement('canvas');
      canvas.width = 300; canvas.height = 150;
      const ctx = canvas.getContext('2d');
      if (!ctx) return { error: 'no-2d' };

      ctx.fillStyle = '#f0f0f0'; ctx.fillRect(0, 0, 300, 150);
      ctx.textBaseline = 'alphabetic';
      ctx.fillStyle = '#000';

      ctx.font = '16px Arial';
      ctx.fillText('AaBbCc1234@汉字🙂', 10, 30);
      ctx.font = '16px "Times New Roman"';
      ctx.fillText('Fingerprint', 10, 55);

      const grad = ctx.createLinearGradient(0, 0, 300, 0);
      grad.addColorStop(0, '#f60'); grad.addColorStop(1, '#06f');
      ctx.fillStyle = grad; ctx.fillRect(10, 70, 280, 20);

      ctx.strokeStyle = '#069'; ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.moveTo(10, 110); ctx.lineTo(290, 110); ctx.stroke();

      const data = canvas.toDataURL();
      return { hash: hash64(data), dataLen: data.length };
    } catch (e) { return { error: String(e) }; }
  }

  async function getAudioFingerprint() {
    try {
      const Ctx = window.OfflineAudioContext || window.webkitOfflineAudioContext;
      if (!Ctx) return { error: 'no-offline-audio' };

      const sampleRate = 44100, length = 44100;
      const ac = new Ctx(1, length, sampleRate);
      const osc = ac.createOscillator(); osc.type = 'triangle'; osc.frequency.value = 1000;
      const comp = ac.createDynamicsCompressor();
      comp.threshold.value = -50; comp.knee.value = 40; comp.ratio.value = 12; comp.attack.value = 0; comp.release.value = 0.25;
      osc.connect(comp); comp.connect(ac.destination); osc.start(0);
      const buffer = await ac.startRendering();
      const channel = buffer.getChannelData(0);

      // 量化采样，降低噪声带来的抖动
      const samples = [];
      const step = Math.floor(channel.length / 20);
      for (let i = 0; i < 20; i++) {
        const v = channel[i * step];
        samples.push(Math.round((v + 1) * 1000)); // [-1,1] -> [0,2000] 量化到整数
      }
      return { hash: hash64(samples.join(',')), samples };
    } catch (e) { return { error: String(e) }; }
  }

  function getFeatureSupport() {
    const supports = (typeof CSS !== 'undefined' && CSS.supports) ? {
      grid: CSS.supports('display', 'grid'),
      sticky: CSS.supports('position', 'sticky'),
      backdropFilter: CSS.supports('backdrop-filter', 'blur(1px)'),
      aspectRatio: CSS.supports('aspect-ratio', '1/1')
    } : {};

    const media = {
      darkMode: !!(window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches),
      reducedMotion: !!(window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches)
    };

    const video = document.createElement('video');
    const audio = document.createElement('audio');
    const canPlay = type => {
      try {
        const res = (type.startsWith('video') ? video : audio).canPlayType(type);
        return res === 'probably' ? 2 : res === 'maybe' ? 1 : 0;
      } catch (e) { return 0; }
    };

    const codecs = {
      'video/mp4; codecs="avc1.42E01E"': canPlay('video/mp4; codecs="avc1.42E01E"'),
      'video/webm; codecs="vp8"': canPlay('video/webm; codecs="vp8"'),
      'video/webm; codecs="vp9"': canPlay('video/webm; codecs="vp9"'),
      'video/mp4; codecs="av01.0.04M.08"': canPlay('video/mp4; codecs="av01.0.04M.08"'),
      'audio/ogg; codecs="vorbis"': canPlay('audio/ogg; codecs="vorbis"'),
      'audio/mpeg': canPlay('audio/mpeg'),
      'audio/webm; codecs="opus"': canPlay('audio/webm; codecs="opus"')
    };

    return { cssSupports: supports, mediaPrefs: media, codecs };
  }

  async function getStorageInfo() {
    let idb = 'unknown';
    try { idb = !!window.indexedDB; } catch (e) { idb = false; }
    let quota = null;
    try {
      if (navigator.storage && navigator.storage.estimate) {
        const { quota: q } = await navigator.storage.estimate();
        quota = q ? Math.round(q / (1024 * 1024)) : null; // MB
      }
    } catch (e) {}
    let ls = false, ss = false;
    try { localStorage.setItem('_fp_t', '1'); ls = true; localStorage.removeItem('_fp_t'); } catch (e) {}
    try { sessionStorage.setItem('_fp_t', '1'); ss = true; sessionStorage.removeItem('_fp_t'); } catch (e) {}
    return { localStorage: ls, sessionStorage: ss, indexedDB: idb, quotaMB: quota };
  }

  async function getPermissions() {
    const out = {};
    if (navigator.permissions && navigator.permissions.query) {
      const names = ['geolocation','notifications','camera','microphone','midi','clipboard-read','clipboard-write','background-sync'];
      for (const name of names) {
        try {
          const res = await navigator.permissions.query({ name });
          out[name] = res.state;
        } catch (e) {
          out[name] = 'unsupported';
        }
      }
    }
    return out;
  }

  async function gather() {
    const [ua, storage] = await Promise.all([getUAData(), getStorageInfo()]);
    const nav = getNavigatorProps();
    const scr = getScreenProps();
    const tz = getTZProps();
    const webgl = getWebGLInfo();
    const canvas = getCanvasFingerprint();
    const audio = await getAudioFingerprint();
    const features = getFeatureSupport();
    const perms = await getPermissions();
    const brave = !!navigator.brave;

    // 严格集合：包含更多高区分度、潜在不稳定项
    const all = {
      ua, nav,
      screen: scr,
      time: tz,
      webgl,
      canvas,
      audio,
      features,
      storage,
      perms,
      brave
    };

    // 稳定集合：滤掉已知易波动的字段，保留相对稳固信号
    const stable = {
      ua: {
        userAgent: ua.userAgent,
        uaData: ua.uaData ? {
          mobile: ua.uaData.mobile,
          architecture: ua.uaData.architecture,
          bitness: ua.uaData.bitness,
          model: ua.uaData.model,
          platform: ua.uaData.platform,
          platformVersion: ua.uaData.platformVersion,
          brands: ua.uaData.brands,
          uaFullVersion: ua.uaData.uaFullVersion
        } : null,
        languages: ua.languages
      },
      nav: {
        hardwareConcurrency: nav.hardwareConcurrency,
        deviceMemory: nav.deviceMemory,
        vendor: nav.vendor,
        maxTouchPoints: nav.maxTouchPoints,
        doNotTrack: nav.doNotTrack,
        webdriver: nav.webdriver
      },
      screen: {
        width: scr.width,
        height: scr.height,
        colorDepth: scr.colorDepth,
        pixelDepth: scr.pixelDepth
      },
      time: tz,
      webgl: {
        vendor: webgl.vendor || '',
        renderer: webgl.renderer || '',
        shadingLanguage: webgl.shadingLanguage || '',
        version: webgl.version || ''
      },
      features: {
        cssSupports: features.cssSupports,
        mediaPrefs: features.mediaPrefs,
        codecs: features.codecs
      },
      storage: {
        localStorage: storage.localStorage,
        sessionStorage: storage.sessionStorage,
        indexedDB: storage.indexedDB
      },
      brave
    };

    const stableStr = stableStringify(stable);
    const strictStr = stableStringify(all);
    const stableHash = hash64(stableStr);
    const strictHash = hash64(strictStr);
    return { stable, all, stableHash, strictHash };
  }

  async function recalc() {
    const noteEl = document.getElementById('note');
    noteEl.textContent = '正在采集… 如果你在 file:// 打开，本页的一些信号可能不可用，建议在 http(s) 或 localhost 测试。';
    try {
      const res = await gather();
      document.getElementById('stableHash').textContent = res.stableHash;
      document.getElementById('strictHash').textContent = res.strictHash;
      document.getElementById('details').textContent = JSON.stringify({ stable: res.stable, strictAll: res.all }, null, 2);
      noteEl.textContent = '完成。提示：隐私浏览器/扩展可能导致 strictHash 在刷新时变化。';
    } catch (e) {
      document.getElementById('details').textContent = '错误：' + e;
      noteEl.textContent = '发生错误。';
    }
  }

  function copyText(t) {
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(t);
    } else {
      const ta = document.createElement('textarea');
      ta.value = t; document.body.appendChild(ta); ta.select();
      try { document.execCommand('copy'); } catch (e) {}
      document.body.removeChild(ta);
    }
  }

  document.getElementById('recalc').addEventListener('click', recalc);
  document.getElementById('copyStable').addEventListener('click', () => copyText(document.getElementById('stableHash').textContent));
  document.getElementById('copyStrict').addEventListener('click', () => copyText(document.getElementById('strictHash').textContent));

  recalc();
})();
</script>
</body>
</html>
