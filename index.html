<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>æµè§ˆå™¨æŒ‡çº¹æµ‹è¯•ï¼ˆç¨³å®š/ä¸¥æ ¼åŒå“ˆå¸Œï¼‰</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 20px; color: #222; }
    h1 { font-size: 20px; margin-bottom: 8px; }
    .row { margin: 8px 0; }
    code { background: #f4f4f4; padding: 2px 4px; border-radius: 3px; }
    button { padding: 6px 10px; margin-left: 8px; }
    pre { background: #f9fafb; padding: 12px; border-radius: 6px; overflow: auto; }
    small { color: #666; }
    details { margin-top: 10px; }
  </style>
</head>
<body>
  <h1>æµè§ˆå™¨æŒ‡çº¹æµ‹è¯•ï¼ˆç¨³å®š/ä¸¥æ ¼åŒå“ˆå¸Œï¼‰</h1>
  <div class="row"><small id="note">å»ºè®®åœ¨ https æˆ– http://localhost ä¸‹æµ‹è¯•ï¼›file:// ä¸‹éƒ¨åˆ†èƒ½åŠ›ä¸å¯ç”¨ã€‚</small></div>

  <div class="row">
    <div>ç¨³å®šæŒ‡çº¹ stableHashï¼ˆå°½é‡åˆ·æ–°ä¸å˜ï¼‰ï¼š
      <code id="stableHash">è®¡ç®—ä¸­â€¦</code>
      <button id="copyStable">å¤åˆ¶</button>
    </div>
  </div>

  <div class="row">
    <div>ä¸¥æ ¼æŒ‡çº¹ strictHashï¼ˆåŒ…å«é«˜åŒºåˆ†åº¦ä¿¡å·ï¼Œå¯èƒ½åœ¨éšç§æ¨¡å¼ä¸‹å˜åŒ–ï¼‰ï¼š
      <code id="strictHash">è®¡ç®—ä¸­â€¦</code>
      <button id="copyStrict">å¤åˆ¶</button>
    </div>
  </div>

  <div class="row">
    <button id="recalc">é‡æ–°è®¡ç®—</button>
  </div>

  <details open>
    <summary>æŸ¥çœ‹åŸå§‹æŒ‡çº¹æ•°æ®ï¼ˆç¨³å®š/ä¸¥æ ¼ç»„æˆï¼‰</summary>
    <pre id="details">æ”¶é›†ä¸­â€¦</pre>
  </details>

<script>
(function() {
  const enc = new TextEncoder();

  // ç®€æ´ç¨³å®šçš„ 64-bit FNV-1a å“ˆå¸Œï¼ˆåå…­è¿›åˆ¶ï¼‰ï¼Œç¦»çº¿å¯ç”¨
  function hash64(str) {
    try {
      const FNV_PRIME = 1099511628211n;
      const OFFSET = 14695981039346656037n;
      let h = OFFSET;
      const bytes = enc.encode(str);
      for (let i = 0; i < bytes.length; i++) {
        h ^= BigInt(bytes[i]);
        h = (h * FNV_PRIME) & 0xFFFFFFFFFFFFFFFFn;
      }
      return h.toString(16).padStart(16, '0');
    } catch (e) {
      // æè€ç¯å¢ƒé€€åŒ–åˆ° 32-bitï¼ˆç°ä»£ Chrome ä¸ä¼šèµ°åˆ°è¿™é‡Œï¼‰
      let h = 0x811c9dc5 >>> 0;
      for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h = (h * 0x01000193) >>> 0;
      }
      return ('00000000' + h.toString(16)).slice(-8);
    }
  }

  // ç¨³å®šçš„ JSON åºåˆ—åŒ–ï¼ˆé€’å½’æ’åºé”®ï¼‰
  function stableStringify(obj) {
    const seen = new WeakSet();
    function inner(o) {
      if (o === null || typeof o !== 'object') return o;
      if (seen.has(o)) return null;
      seen.add(o);
      if (Array.isArray(o)) return o.map(inner);
      const out = {};
      Object.keys(o).sort().forEach(k => { out[k] = inner(o[k]); });
      return out;
    }
    return JSON.stringify(inner(obj));
  }

  function normalizeBrandList(list) {
    try {
      const known = ['Chromium','Google Chrome','Microsoft Edge','Opera','OPR','Brave','Vivaldi','Samsung Internet','YaBrowser','Yandex','Chrome','Edge','UC Browser','QQBrowser'];
      const cleaned = (list || [])
        .map(x => ({ brand: x.brand || x.brandName || '', version: x.version || x.versionNumber || '' }))
        .filter(x => x.brand && known.some(k => x.brand.includes(k)));
      cleaned.sort((a, b) => (a.brand + a.version).localeCompare(b.brand + b.version));
      return cleaned;
    } catch (e) { return []; }
  }

  async function getUAData() {
    const result = {
      userAgent: navigator.userAgent || '',
      platform: navigator.platform || '',
      languages: (navigator.languages || [navigator.language || '']).slice().filter(Boolean)
    };
    result.languages.sort();
    const uaData = navigator.userAgentData;
    if (uaData && uaData.getHighEntropyValues) {
      try {
        const high = await uaData.getHighEntropyValues([
          'architecture','bitness','model','platform','platformVersion','uaFullVersion','fullVersionList','wow64'
        ]);
        result.uaData = {
          mobile: !!uaData.mobile,
          architecture: high.architecture || '',
          bitness: high.bitness || '',
          model: high.model || '',
          platform: high.platform || '',
          platformVersion: high.platformVersion || '',
          uaFullVersion: high.uaFullVersion || '',
          wow64: !!high.wow64,
          brands: normalizeBrandList(high.fullVersionList || uaData.brands || [])
        };
      } catch (e) {
        result.uaDataError = String(e);
      }
    }
    return result;
  }

  function getNavigatorProps() {
    return {
      hardwareConcurrency: navigator.hardwareConcurrency ?? null,
      deviceMemory: navigator.deviceMemory ?? null,
      maxTouchPoints: navigator.maxTouchPoints ?? 0,
      vendor: navigator.vendor || '',
      product: navigator.product || '',
      productSub: navigator.productSub || '',
      doNotTrack: navigator.doNotTrack ?? null,
      webdriver: !!navigator.webdriver,
      cookieEnabled: !!navigator.cookieEnabled,
      onLine: !!navigator.onLine
    };
  }

  function getScreenProps() {
    const s = window.screen || {};
    const o = s.orientation || {};
    return {
      width: s.width ?? null,
      height: s.height ?? null,
      availWidth: s.availWidth ?? null,
      availHeight: s.availHeight ?? null,
      colorDepth: s.colorDepth ?? null,
      pixelDepth: s.pixelDepth ?? null,
      devicePixelRatio: window.devicePixelRatio || 1,
      orientationType: o.type || '',
      orientationAngle: o.angle || 0
    };
  }

  function getTZProps() {
    const tz = (Intl && Intl.DateTimeFormat) ? Intl.DateTimeFormat().resolvedOptions().timeZone : '';
    const offset = new Date().getTimezoneOffset();
    const locale = (navigator.languages && navigator.languages[0]) || navigator.language || '';
    return { timeZone: tz || '', timeOffsetMinutes: offset, locale };
  }

  function getWebGLInfo() {
    const out = {};
    try {
      const canvas = document.createElement('canvas');
      const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
      if (gl) {
        const dbg = gl.getExtension('WEBGL_debug_renderer_info');
        out.vendor = gl.getParameter(dbg ? dbg.UNMASKED_VENDOR_WEBGL : gl.VENDOR);
        out.renderer = gl.getParameter(dbg ? dbg.UNMASKED_RENDERER_WEBGL : gl.RENDERER);
        out.version = gl.getParameter(gl.VERSION);
        out.shadingLanguage = gl.getParameter(gl.SHADING_LANGUAGE_VERSION);
        const aniso = gl.getExtension('EXT_texture_filter_anisotropic') ||
                      gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic') ||
                      gl.getExtension('MOZ_EXT_texture_filter_anisotropic');
        out.maxAnisotropy = aniso ? gl.getParameter(aniso.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : null;
      } else {
        out.error = 'no-webgl';
      }
    } catch (e) { out.error = String(e); }
    return out;
  }

  function getCanvasFingerprint() {
    try {
      const canvas = document.createElement('canvas');
      canvas.width = 300; canvas.height = 150;
      const ctx = canvas.getContext('2d');
      if (!ctx) return { error: 'no-2d' };

      ctx.fillStyle = '#f0f0f0'; ctx.fillRect(0, 0, 300, 150);
      ctx.textBaseline = 'alphabetic';
      ctx.fillStyle = '#000';

      ctx.font = '16px Arial';
      ctx.fillText('AaBbCc1234@æ±‰å­—ğŸ™‚', 10, 30);
      ctx.font = '16px "Times New Roman"';
      ctx.fillText('Fingerprint', 10, 55);

      const grad = ctx.createLinearGradient(0, 0, 300, 0);
      grad.addColorStop(0, '#f60'); grad.addColorStop(1, '#06f');
      ctx.fillStyle = grad; ctx.fillRect(10, 70, 280, 20);

      ctx.strokeStyle = '#069'; ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.moveTo(10, 110); ctx.lineTo(290, 110); ctx.stroke();

      const data = canvas.toDataURL();
      return { hash: hash64(data), dataLen: data.length };
    } catch (e) { return { error: String(e) }; }
  }

  async function getAudioFingerprint() {
    try {
      const Ctx = window.OfflineAudioContext || window.webkitOfflineAudioContext;
      if (!Ctx) return { error: 'no-offline-audio' };

      const sampleRate = 44100, length = 44100;
      const ac = new Ctx(1, length, sampleRate);
      const osc = ac.createOscillator(); osc.type = 'triangle'; osc.frequency.value = 1000;
      const comp = ac.createDynamicsCompressor();
      comp.threshold.value = -50; comp.knee.value = 40; comp.ratio.value = 12; comp.attack.value = 0; comp.release.value = 0.25;
      osc.connect(comp); comp.connect(ac.destination); osc.start(0);
      const buffer = await ac.startRendering();
      const channel = buffer.getChannelData(0);

      // é‡åŒ–é‡‡æ ·ï¼Œé™ä½å™ªå£°å¸¦æ¥çš„æŠ–åŠ¨
      const samples = [];
      const step = Math.floor(channel.length / 20);
      for (let i = 0; i < 20; i++) {
        const v = channel[i * step];
        samples.push(Math.round((v + 1) * 1000)); // [-1,1] -> [0,2000] é‡åŒ–åˆ°æ•´æ•°
      }
      return { hash: hash64(samples.join(',')), samples };
    } catch (e) { return { error: String(e) }; }
  }

  function getFeatureSupport() {
    const supports = (typeof CSS !== 'undefined' && CSS.supports) ? {
      grid: CSS.supports('display', 'grid'),
      sticky: CSS.supports('position', 'sticky'),
      backdropFilter: CSS.supports('backdrop-filter', 'blur(1px)'),
      aspectRatio: CSS.supports('aspect-ratio', '1/1')
    } : {};

    const media = {
      darkMode: !!(window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches),
      reducedMotion: !!(window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches)
    };

    const video = document.createElement('video');
    const audio = document.createElement('audio');
    const canPlay = type => {
      try {
        const res = (type.startsWith('video') ? video : audio).canPlayType(type);
        return res === 'probably' ? 2 : res === 'maybe' ? 1 : 0;
      } catch (e) { return 0; }
    };

    const codecs = {
      'video/mp4; codecs="avc1.42E01E"': canPlay('video/mp4; codecs="avc1.42E01E"'),
      'video/webm; codecs="vp8"': canPlay('video/webm; codecs="vp8"'),
      'video/webm; codecs="vp9"': canPlay('video/webm; codecs="vp9"'),
      'video/mp4; codecs="av01.0.04M.08"': canPlay('video/mp4; codecs="av01.0.04M.08"'),
      'audio/ogg; codecs="vorbis"': canPlay('audio/ogg; codecs="vorbis"'),
      'audio/mpeg': canPlay('audio/mpeg'),
      'audio/webm; codecs="opus"': canPlay('audio/webm; codecs="opus"')
    };

    return { cssSupports: supports, mediaPrefs: media, codecs };
  }

  async function getStorageInfo() {
    let idb = 'unknown';
    try { idb = !!window.indexedDB; } catch (e) { idb = false; }
    let quota = null;
    try {
      if (navigator.storage && navigator.storage.estimate) {
        const { quota: q } = await navigator.storage.estimate();
        quota = q ? Math.round(q / (1024 * 1024)) : null; // MB
      }
    } catch (e) {}
    let ls = false, ss = false;
    try { localStorage.setItem('_fp_t', '1'); ls = true; localStorage.removeItem('_fp_t'); } catch (e) {}
    try { sessionStorage.setItem('_fp_t', '1'); ss = true; sessionStorage.removeItem('_fp_t'); } catch (e) {}
    return { localStorage: ls, sessionStorage: ss, indexedDB: idb, quotaMB: quota };
  }

  async function getPermissions() {
    const out = {};
    if (navigator.permissions && navigator.permissions.query) {
      const names = ['geolocation','notifications','camera','microphone','midi','clipboard-read','clipboard-write','background-sync'];
      for (const name of names) {
        try {
          const res = await navigator.permissions.query({ name });
          out[name] = res.state;
        } catch (e) {
          out[name] = 'unsupported';
        }
      }
    }
    return out;
  }

  async function gather() {
    const [ua, storage] = await Promise.all([getUAData(), getStorageInfo()]);
    const nav = getNavigatorProps();
    const scr = getScreenProps();
    const tz = getTZProps();
    const webgl = getWebGLInfo();
    const canvas = getCanvasFingerprint();
    const audio = await getAudioFingerprint();
    const features = getFeatureSupport();
    const perms = await getPermissions();
    const brave = !!navigator.brave;

    // ä¸¥æ ¼é›†åˆï¼šåŒ…å«æ›´å¤šé«˜åŒºåˆ†åº¦ã€æ½œåœ¨ä¸ç¨³å®šé¡¹
    const all = {
      ua, nav,
      screen: scr,
      time: tz,
      webgl,
      canvas,
      audio,
      features,
      storage,
      perms,
      brave
    };

    // ç¨³å®šé›†åˆï¼šæ»¤æ‰å·²çŸ¥æ˜“æ³¢åŠ¨çš„å­—æ®µï¼Œä¿ç•™ç›¸å¯¹ç¨³å›ºä¿¡å·
    const stable = {
      ua: {
        userAgent: ua.userAgent,
        uaData: ua.uaData ? {
          mobile: ua.uaData.mobile,
          architecture: ua.uaData.architecture,
          bitness: ua.uaData.bitness,
          model: ua.uaData.model,
          platform: ua.uaData.platform,
          platformVersion: ua.uaData.platformVersion,
          brands: ua.uaData.brands,
          uaFullVersion: ua.uaData.uaFullVersion
        } : null,
        languages: ua.languages
      },
      nav: {
        hardwareConcurrency: nav.hardwareConcurrency,
        deviceMemory: nav.deviceMemory,
        vendor: nav.vendor,
        maxTouchPoints: nav.maxTouchPoints,
        doNotTrack: nav.doNotTrack,
        webdriver: nav.webdriver
      },
      screen: {
        width: scr.width,
        height: scr.height,
        colorDepth: scr.colorDepth,
        pixelDepth: scr.pixelDepth
      },
      time: tz,
      webgl: {
        vendor: webgl.vendor || '',
        renderer: webgl.renderer || '',
        shadingLanguage: webgl.shadingLanguage || '',
        version: webgl.version || ''
      },
      features: {
        cssSupports: features.cssSupports,
        mediaPrefs: features.mediaPrefs,
        codecs: features.codecs
      },
      storage: {
        localStorage: storage.localStorage,
        sessionStorage: storage.sessionStorage,
        indexedDB: storage.indexedDB
      },
      brave
    };

    const stableStr = stableStringify(stable);
    const strictStr = stableStringify(all);
    const stableHash = hash64(stableStr);
    const strictHash = hash64(strictStr);
    return { stable, all, stableHash, strictHash };
  }

  async function recalc() {
    const noteEl = document.getElementById('note');
    noteEl.textContent = 'æ­£åœ¨é‡‡é›†â€¦ å¦‚æœä½ åœ¨ file:// æ‰“å¼€ï¼Œæœ¬é¡µçš„ä¸€äº›ä¿¡å·å¯èƒ½ä¸å¯ç”¨ï¼Œå»ºè®®åœ¨ http(s) æˆ– localhost æµ‹è¯•ã€‚';
    try {
      const res = await gather();
      document.getElementById('stableHash').textContent = res.stableHash;
      document.getElementById('strictHash').textContent = res.strictHash;
      document.getElementById('details').textContent = JSON.stringify({ stable: res.stable, strictAll: res.all }, null, 2);
      noteEl.textContent = 'å®Œæˆã€‚æç¤ºï¼šéšç§æµè§ˆå™¨/æ‰©å±•å¯èƒ½å¯¼è‡´ strictHash åœ¨åˆ·æ–°æ—¶å˜åŒ–ã€‚';
    } catch (e) {
      document.getElementById('details').textContent = 'é”™è¯¯ï¼š' + e;
      noteEl.textContent = 'å‘ç”Ÿé”™è¯¯ã€‚';
    }
  }

  function copyText(t) {
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(t);
    } else {
      const ta = document.createElement('textarea');
      ta.value = t; document.body.appendChild(ta); ta.select();
      try { document.execCommand('copy'); } catch (e) {}
      document.body.removeChild(ta);
    }
  }

  document.getElementById('recalc').addEventListener('click', recalc);
  document.getElementById('copyStable').addEventListener('click', () => copyText(document.getElementById('stableHash').textContent));
  document.getElementById('copyStrict').addEventListener('click', () => copyText(document.getElementById('strictHash').textContent));

  recalc();
})();
</script>
</body>
</html>
